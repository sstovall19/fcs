package Fap::Model::DBIx::Result;
use base 'DBIx::Class::Core';
use strict;
$SIG{__WARN__} = sub { foreach (@_) {  print STDERR "$_\n" if ($_!~/Prefetch/);} };



sub strip {
    my ( $self, @records ) = @_;
    my @ret;
    @records = ($self) if ( !scalar(@records) );
    my $uidh = {};
    foreach my $rec (@records) {
        if ( !$rec || $uidh->{ $rec->id } ) { next; }
        my $trec = { $rec->get_columns() };
        if ( $rec->{related_resultsets} ) {
            my $ttr = {};
            my $ref = ( $rec->can("map_reference") ) ? $rec->map_reference : undef;
            if ( $ref && scalar( grep { defined $ref->{$_} } keys %{ $rec->{related_resultsets} } ) ) {
                my @rett;
                foreach my $reference ( sort keys %$ref ) {
                    my @rt;
                    foreach ( $rec->$reference ) {
                        my $subref = $ref->{$reference};
                        push( @rt, $_->strip()->{$subref} );
                    }
                    if ( scalar(@rt) > 1 || $ref->{$reference} =~ /s$/ ) {
                        $trec->{ $ref->{$reference} } = [@rt];
                    } else {
                        $trec->{ $ref->{$reference} } = $rt[0];
                    }
                }
            }
            foreach my $join ( sort keys %{ $rec->{related_resultsets} } ) {
		$uidh={};
                next if ( $ref && $ref->{$join} );
                my @records;
                foreach ( $rec->$join ) {
                    next if ( !$_ || $uidh->{ $_->id } );
                    push( @records, $_->strip() );
                    $uidh->{ $_->id } = 1;
                }
                if ( scalar(@records) > 1 || $join =~ /s$/ && $join!~/status$/) {
                    $trec->{$join} = [@records];
                } else {
                    $trec->{$join} = $records[0];
                }
            }
        }
        push( @ret, $trec );
    }
    if (wantarray) {
        return @ret;
    } else {
        if ( scalar(@ret) > 1 ) {
            return [@ret];
        } else {
            return $ret[0];
        }
    }
}

sub update {
    my ( $self, @args ) = @_;

    if ( $self->operation_is_allowed("update")) {
        return $self->SUPER::update(@args);
    } else {
        $self->throw_error("YOU SHALL NOT PASS!\n");
    }
}

sub delete {
    my ( $self, @args ) = @_;

    if ( $self->operation_is_allowed("delete")) {
        return $self->SUPER::delete(@args);
    } else {
        $self->throw_error("YOU SHALL NOT PASS!");
    }
}

sub throw_error {
    my ( $self, $msg ) = @_;

    die $msg;
}

sub uniqueify {
    my ( $self, @records ) = @_;
    my @ret;
    @records = ($self) if ( !scalar(@records) );
    my $uidh = {};
    foreach my $rec (@records) {
        if ( !$rec || $uidh->{ $rec->id } ) { next; }
        if ( $rec->{related_resultsets} ) {
            my $ttr = {};
            foreach my $join ( sort keys %{ $rec->{related_resultsets} } ) {
                if ( ref( $rec->$join ) eq "DBIx::Class::ResultSet" ) {
                    bless $rec->{related_resultsets}->{$join}, "Fap::Model::DBIx::ResultSet";
                }
                my @records;
                foreach ( $rec->$join ) {
                    next if ( !$_ || $uidh->{ $_->id });
                    push( @records, $_->uniqueify() );
                    $uidh->{ $_->id } = 1;
                }
                $rec->$join->row_count( scalar(@records) ) if ( ref( $rec->$join ) =~ /ResultSet$/ );
                $rec->{related_resultsets}->{$join}->{all_cache} = [@records];
                $rec->{related_resultsets}->{$join}->{row_count} = scalar(@records);

            }
        }
        push( @ret, $rec );
    }
    if (wantarray) {
        return @ret;
    } else {
        if ( scalar(@ret) > 1 ) {
            return [@ret];
        } else {
            return $ret[0];
        }
    }
}

sub operation_is_allowed {
	my ($self,$optype) = @_;

	return 1;
}
sub allowed_operations {
	return {update=>1,delete=>1};
}

sub column_defaults {
	return {}
}

sub insert {
        my ($self,@yams) = @_;

	my $defs = $self->column_defaults();
	foreach my $def (keys %$defs) {
		$self->$def($defs->{$def}) if(!$self->$def);
	}

        return $self->SUPER::insert(@yams);
}
sub use_db {
	return undef;
}



1;
__DATA__




#################### pod generated by Pod::Autopod - keep this line to make pod updates possible ####################

=head1 NAME

Fap::Model::DBIx::Result


=head1 DESCRIPTION

pod generated by Pod::Autopod - keep this line to make pod updates possible ####################


=head1 REQUIRES


=head1 IMPLEMENTS

L<DBIx::Class::Core> 


=head1 METHODS

=head2 allowed_operations

 $this->allowed_operations();

=head2 delete

 $this->delete();

=head2 operation_is_allowed

 $this->operation_is_allowed();

=head2 strip

 $this->strip();

=head2 throw_error

 $this->throw_error();

=head2 uniqueify

 $this->uniqueify();

=head2 update

 $this->update();


=cut

